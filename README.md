# JPMC-tech-task-2-PY3

JPMorgan Chase Software Engineering virtual internship task -1

I am doing virtual internship on JPMorgan Chase Software Engineering for that purpose i created this repo and i am going to share how finsish my task that was given by JPMorgan Chase Software Engineering

before going to task i like to share how i get this internship.

I get the internship on this website insidesherpa <a href="https://www.insidesherpa.com/"> click here</a>
other than JPMorgan Chase Software Engineering lot's of company offer free virtual internship including Microsoft,......

This repo for the task 2<br/>
<hr>
<h3> WARNING: My English not so good. so applogize me </h3>
<hr>
<h1>Task2 </h1>

<p>Here is the background information on our task

Typically, traders monitor stock prices and trading strategies by having data displayed visually on their screens in chart form. Often these charts will be accompanied by alerts that notify users when certain events occur or when preset price thresholds are hit.

JPMorgan Chase created the Perspective tool over many years to allows users to present and manipulate data feeds visually in web applications.

Perspective provides a set of flexible data transforms, such as pivots, filters, and aggregations. It utilizes bleeding-edge browser technology such as Web Assembly and Apache Arrow and is unmatched in browser performance. It is engineered for reliability and production-vetted on the JPMorgan Chase trading floor and is now available to the development community as Open Source. If you want to explore that, a link is provided in the resources section. 

* Understanding the finance and trading part is not required for this task.

* Being familiar with python scripting language, command line basics, javascript, react and typescript are not required for this task too as you will be guided in this exercise
</p>

<p>
For the second module of this project will need you to accomplish the following:

1.Set up your system by downloading the necessary files, tools and dependencies. 
  
2.Fix the broken typescript files in repository to make the web application output correctly.
  
3.Generate a patch file of the changes you made.
 
</p>
<hr>

<h1>Step1:Set up your system </h1>
 how to setup your enviroment for this task <a href="https://insidesherpa.s3.amazonaws.com/vinternships/companyassets/Sj7temL583QAYpHXD/setup_devenv_m1_v6.pdf" >Click Here</a> <br/>
 <p> how to run the code </p>
 <pre>
 python datafeed/server3.py // it start the server
 npm install  // it install the dependency pkg
 npm start  // it start our app
 </pre>
 
 <hr>
 
<h1>Step2:Fix the broken typescript files in repository to make the web application output correctly</h1>
<p>
 Before fixing the broken Typescript files. we need to know some basic that are </p>
 <ol>
  <li> The file structure of the program </li>
 <pre>
├───datafeed ->which the server3.py and test(excel file ) 
├───public  ->index.html (our main html code is here the html code generated by a react is insert here while excuting the code )
└───src 
      |--index.tsx ->  this typescript program is responsible for render the whole app
      |--index.css -> this css file for index.tsx  for styling purpose
      |--App.tsx  ->this is the main typescript code 
      |--App.test.js   -> this for testing purpose  
      |--App.css -> css file for our main app.tsx(typescript)
      |--DataStreamer.ts  -> this typescript program is responsible for get data from the server
      |--Graph.tsx  -> this  typescript program is responsible for drawing a graph on the browser
      |--Graph.css  -> this css file for graph.tsx 
</pre>

<p>The above codes are work fine but we need to modify the code such that it show the top_ask price from the two stocks("ABC","DEF") in graph
and need to uppdate the graph according to the data get from the server 
</p>
<p>
so let's get start<p>
<p>To achieve this we have to change (2) files: src/App.tsx and src/Graph.tsx<p>
 
<h3>Making changes in `App.tsx`</h3>
<p>
● App.tsx is the main app (typescript) file of our client side react application.

● Don’t be intimidated by words like React, which is just a javascript library to
help us build interfaces and ui components, or Typescript which is just a
superset of javascript but is still alike with javascript but with stronger type
checking...
</p>
<p>
App.tsx or the App component, is basically the first component our browser
will render as it’s the parent component of the other parts of the simple page
that shows up when you first started the application in the set up phase.
</p>
<p>
● Components are basically the building blocks / parts of our web application. A
component has a common set of properties / functions and as such, each
unique component just inherits from the base React component

</p>
<p>
First we need to add the `showGraph` property in the IState interface
defined in App.tsx. It should be of the type` boolean`because we need to render the graph only if the user click the button star stream data 
so the code look like this 
</p>
<h4> Before change</h4>
<pre>
interface IState {
  // this is used to store the data get from the server the type of data is SeverRespond 
  data: ServerRespond[], 
}
</pre>
<h4>After change</h4>
<pre>
interface IState {
  // this is used to store the data get from the server the type of data is SeverRespond 
  data: ServerRespond[],
  showGraph: boolean,
}
</pre>
<p>
Next, in the constructor of the App component, you should define that the
initial state of the App not to show the graph yet. This is because we want the
graph to show when the user clicks ‘Start Streaming Data’. That means you
should set `showGraph` property of the App’s state to `false` in the
constructor</p>

so the code look like this 

<h4> Before change</h4>
<pre>
class App extends Component<{}, IState> {
  constructor(props: {}) {
    super(props);
    this.state = {
      data: [],   
    };
  }
</pre>

<h4> After change</h4>
<pre>
class App extends Component<{}, IState> {
  constructor(props: {}) {
    super(props);
    this.state = {
      data: [],
      showGraph: false,
    };
  }
</pre>
<p>
To ensure that the graph doesn’t render until a user clicks the ‘Start
Streaming’ button, you should also edit the `renderGraph` method of the
App. In there, you must add a condition to only render the graph when the
state’s `showGraph` property of the App’s state is `true`.
</p>

so the code look like this 

<h4> Before change</h4>
<pre>
  renderGraph() {
       // return the graph component 
       return (&lt;Graph data={this.state.data}/&gt;)
  }
</pre>

<h4> After change</h4>
<pre>
  renderGraph() {
   //checking if user clicked or not  
    if (this.state.showGraph) {
      // return the graph component 
      return (&lt;Graph data={this.state.data}/&gt;)
    }
  }
</pre>

<p>
Finally, we must also modify the `getDataFromServer`method to contact the
server and get data from it continuously instead of just getting data from it
once every time you click the button.
</p>
<p>
Javascript has a way to do things in intervals and that is via the setInterval
function. What we can do to make it continuous (at least up to an extended
period of time) is to have a guard value that we can check against when to
stop / clear the interval process we started.
</p>

so the code look like this 

<h4> Before change</h4>
<pre>
getDataFromServer() {
   DataStreamer.getData((serverResponds: ServerRespond[]) => {
      // Update the state by creating a new array of data that consists of
      // Previous data in the state and the new data from server
      this.setState({ data: [...this.state.data, ...serverResponds] });
    });
  }
</pre>

<h4> After change</h4>
<pre>
getDataFromServer() {
    //using a counter to clear the inerval after 1000ms 
    let x = 0;
    //using arrow function to avoid "this" binding problem
    const interval = setInterval(() => {
      DataStreamer.getData((serverResponds: ServerRespond[]) => {
       //setting the data to serverrespond data and showgraph as true
        this.setState({
          data: serverResponds,
          showGraph: true,
        });
      });
      x++;
      if (x > 1000) {
       //clear interval after 1000ms
        clearInterval(interval);
      }
    }, 100);
    //calling the arrow function for each 100ms 
  }
</pre>
<h3>Making changes in `Graph.tsx`</h3>
<p> Next we going to make changes in Graph.tsx file 
  
● To completely achieve the desired output, we must also make changes to the
`Graph.tsx` file. This is the file that takes care of how the Graph component
of our App will be rendered and react to the state changes that occur within
the App.
● First, you must enable the `PerspectiveViewerElement` to behave like an
HTMLElement. To do this, you can extend the `HTMLElement` class from the
`PerspectiveViewerElement` interface.
</p>
so the code look like this 

<h4> Before change</h4>
<pre>
interface PerspectiveViewerElement {
  load: (table: Table) => void,
}
</pre>

<h4> After change</h4>
<pre>
 interface PerspectiveViewerElement extends HTMLElement {
  load: (table: Table) => void,
}
</pre>

<p>
● After doing this, we now need to modify `componentDidMount` method. Just
as a note, the componentDidMount() method runs after the component
output has been rendered to the DOM. If you want to learn more about it and
other lifecycle methods/parts of react components, read more here.
● Since we have changed the `PerspectiveViewerElement` to extend the
`HTMLElement` earlier, you can now make the definition of the `const elem`
simpler, i.e. you can just assign it straight to the result of the
`document.getElementsByTagName`.
</p>

so the code look like this 

<h4> Before change</h4>
<pre>
componentDidMount() {
    // Get element to attach the table from the DOM.
    const elem: PerspectiveViewerElement = document.getElementsByTagName('perspective-viewer')[0] as unknown as PerspectiveViewerElement;

</pre>

<h4> After change</h4>
<pre>
componentDidMount() {
    // Get element to attach the table from the DOM.
    //no need to tell that element is  PerspectiveViewerElement because we extend the HTMLElement
    const elem = document.getElementsByTagName('perspective-viewer')[0] as unknown as PerspectiveViewerElement;
</pre>
<p>
Finally, we need to add more attributes to the element. For this we have to
have read thru the Perspective configurations particularly on the table.view
configurations. we need to add the following attributes: `view`,
`column-pivots`, `row-pivots`, `columns` and `aggregates` .
</p>
so the code look like this 

<h4> Before change</h4>
<pre>
componentDidMount() {
    ....
    ....
     if (this.table) {
      // Load the `table` in the `<perspective-viewer>` DOM reference.
      elem.load(this.table);
    }
  }
</pre>
<h4> After change</h4>
<pre>
componentDidMount() {
    ....
    ....
     if (this.table) {
      // Load the `table` in the `<perspective-viewer>` DOM reference.
      elem.load(this.table);
      /* adding attribute to Perspective-viewer elements*/
      /*set view to y_line*/
      elem.setAttribute('view','y_line');
      /* set column-pivots to stock (ABC or DEF)*/
      elem.setAttribute('column-pivots','["stock"]');
       /* set row-pivots to timestamp*/
      elem.setAttribute('row-pivots','["timestamp"]');
     /* set columns to top_ask_price */
      elem.setAttribute('columns','["top_ask_price"]');
      /*aggregates to avoid duplicate data*/
       elem.setAttribute('aggregates','{"stock":"distinct count","top_ask_price":"avg","top_bid_price": "avg","timestamp": "distinct count"}');
    }
  }
</pre>
<p>
Changes in Graph.tsx are done too. By now we should have  accomplished all the objectives of the task.
</p>

<hr/>

<h1>Step3.Generate a patch file of the changes you made.</h1>
<p>
Follow this steps to create patch file 
Fire up a terminal, enter the repository via the terminal you opened (via the cd
<repo_name_here> aka change directory command) and do the following commands
(one line, one command)</p><br/>
<ol>
<li>git add -A</li>
<li>git config user.email "<your_email_address>"</li>
<li>git config user.name "<your_name>"</li>
<li>git commit -m 'Create Patch File'</li>
<li>git format-patch -1 HEAD</li>
</ol>
<br/>
<br/>
The final command, i.e. git format-patch -1 HEAD, should produce the .patch file
you’d want to submit to complete this module. It will be located in the directory
where you executed the command.
<hr>

<h1>Resource</h1>
<p> Finally i am going to share the resource i used for this task</p>
<ol>
  <li>Node js resource</li>
  <ol>
    <li> <a href="https://www.youtube.com/watch?v=fBNz5xF-Kx4">YouTube videos</a></li>
    <li> <a href="https://www.youtube.com/watch?v=vJEO57B05Sg">YouTube videos</a></li>
    <li> <a href="https://www.youtube.com/watch?v=TlB_eWDSMt4">YouTube videos</a></li>
  </ol>
    

<li>React js resource</li>
  <ol>
    <li> <a href="https://www.youtube.com/watch?v=sBws8MSXN7A&t=682s">YouTube videos</a></li>
    <li> <a href="https://www.youtube.com/watch?v=nvHeB32ICDM">YouTube videos</a></li>
    <li> <a href="https://www.youtube.com/watch?v=Ke90Tje7VS0">YouTube videos</a></li>
  </ol>
  
<li>Type Script resource</li>
  <ol>
    <li> <a href="https://www.youtube.com/watch?v=NjN00cM18Z4">YouTube videos</a></li>
    <li> <a href="https://www.youtube.com/watch?v=rAy_3SIqT-E">YouTube videos</a></li>
    <li> <a href="https://www.youtube.com/watch?v=ahCwqrYpIuM">YouTube videos</a></li>
  </ol><br/>
  <p>Last but not least <a href="https://www.w3schools.com/">W3School</a></p>
  </ol>
  
<hr>
<h1> Conclusion</h1>

<p> What are the things i learned from this task</p>
<ol>
  <li> Node js fundamental</li>
  <li> React js fundamental</li>
  <li> Type Scrip fundamental</li>
</ol><br/>
<hr>
           <p> ALL THE BEST</p><br/>
<hr>
